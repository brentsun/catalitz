{"version":3,"sources":["../../src/coders/idGenerator.js"],"names":["constants","namespace_base_id","namespace_max_depth","name_pattern","generateId","parentId","name","hash","sha3_256","create","update","Uint32Array","from","buffer","result","arrayBuffer","throwInvalidFqn","reason","Error","findMosaicSeparatorIndex","mosaicSeparatorIndex","lastIndexOf","extractPartName","start","size","partName","substr","test","append","path","id","length","push","split","processor","index","idGenerator","generateMosaicId","namespaceName","namespacePath","generateNamespacePath","namespaceId","substringStart"],"mappings":"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","file":"idGenerator.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { sha3_256 } from 'js-sha3';\n\nconst constants = {\n\tnamespace_base_id: [0, 0],\n\tnamespace_max_depth: 3,\n\tname_pattern: /^[a-z0-9][a-z0-9-_]*$/\n};\n\nfunction generateId(parentId, name) {\n\tconst hash = sha3_256.create();\n\thash.update(Uint32Array.from(parentId).buffer);\n\thash.update(name);\n\tconst result = new Uint32Array(hash.arrayBuffer());\n\treturn [result[0], result[1]];\n}\n\nfunction throwInvalidFqn(reason, name) {\n\tthrow Error(`fully qualified id is invalid due to ${reason} (${name})`);\n}\n\nfunction findMosaicSeparatorIndex(name) {\n\tconst mosaicSeparatorIndex = name.lastIndexOf(':');\n\tif (0 > mosaicSeparatorIndex)\n\t\tthrowInvalidFqn('missing mosaic', name);\n\n\tif (0 === mosaicSeparatorIndex)\n\t\tthrowInvalidFqn('empty part', name);\n\n\treturn mosaicSeparatorIndex;\n}\n\nfunction extractPartName(name, start, size) {\n\tif (0 === size)\n\t\tthrowInvalidFqn('empty part', name);\n\n\tconst partName = name.substr(start, size);\n\tif (!constants.name_pattern.test(partName))\n\t\tthrowInvalidFqn(`invalid part name [${partName}]`, name);\n\n\treturn partName;\n}\n\nfunction append(path, id, name) {\n\tif (constants.namespace_max_depth === path.length)\n\t\tthrowInvalidFqn('too many parts', name);\n\n\tpath.push(id);\n}\n\nfunction split(name, processor) {\n\tlet start = 0;\n\tfor (let index = 0; index < name.length; ++index) {\n\t\tif ('.' === name[index]) {\n\t\t\tprocessor(start, index - start);\n\t\t\tstart = index + 1;\n\t\t}\n\t}\n\n\treturn start;\n}\n\n/** @exports coders/idGenerator */\nconst idGenerator = {\n\t/**\n\t * Generates a mosaic id given a unified mosaic name.\n\t * @param {string} name The unified mosaic name.\n\t * @returns {module:coders/uint64~uint64} The mosaic id.\n\t */\n\tgenerateMosaicId: name => {\n\t\tif (0 >= name.length)\n\t\t\tthrowInvalidFqn('having zero length', name);\n\n\t\tconst mosaicSeparatorIndex = findMosaicSeparatorIndex(name);\n\n\t\tconst namespaceName = name.substr(0, mosaicSeparatorIndex);\n\t\tconst namespacePath = idGenerator.generateNamespacePath(namespaceName);\n\t\tconst namespaceId = namespacePath[namespacePath.length - 1];\n\n\t\treturn generateId(\n\t\t\tnamespaceId,\n\t\t\textractPartName(name, mosaicSeparatorIndex + 1, name.length - mosaicSeparatorIndex - 1)\n\t\t);\n\t},\n\n\t/**\n\t * Parses a unified namespace name into a path.\n\t * @param {string} name The unified namespace name.\n\t * @returns {array<module:coders/uint64~uint64>} The namespace path.\n\t */\n\tgenerateNamespacePath: name => {\n\t\tif (0 >= name.length)\n\t\t\tthrowInvalidFqn('having zero length', name);\n\n\t\tlet namespaceId = constants.namespace_base_id;\n\t\tconst path = [];\n\t\tconst start = split(name, (substringStart, size) => {\n\t\t\tnamespaceId = generateId(namespaceId, extractPartName(name, substringStart, size));\n\t\t\tappend(path, namespaceId, name);\n\t\t});\n\n\t\tnamespaceId = generateId(namespaceId, extractPartName(name, start, name.length - start));\n\t\tappend(path, namespaceId, name);\n\t\treturn path;\n\t}\n};\n\nexport default idGenerator;\n"]}